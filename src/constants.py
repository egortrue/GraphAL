# ---------------------------------------------------------------------- #
#                         Define constants                               #
# ---------------------------------------------------------------------- #


# ----------------------- Common constants ----------------------------- #
FONT_12 = 'Calibri 12'
FONT_14 = 'Calibri 14'
SIZE_BUTTON = (8, 1)


# ----------------------- Main tab constants --------------------------- #
SIZE_LABEL_MAIN_TAB = (11, 1)
SIZE_INPUT_MAIN_TAB = (14, 1)


# ----------------------- Preview tab constants ------------------------ #
COLOR_IN_PREVIEW = 'white'


# --------------- Definition of algorithms in main_tab ----------------- #

dfs_main_tab = "Дан произвольный граф. Алгоритм поиска в глубину позволяет построить обход графа,\
при котором посещаются все вершины, доступные из начальной вершины."

bfs_main_tab = "Дан невзвешенный (ориентированный или неориентированный) граф.\
 Алгоритм поиска в ширину позволяет найти кратчайшие пути из одной вершины до всех остальных вершин."

Dijkstra_algorithm_main_tab = "Дан взвешенный ориентированный граф. Алгоритм позволяет найти кратчайшие пути от\
одной вершины до всех остальных, при условии, что все ребра в графе имеют неотрицательные веса."

Ford_Bellman_algorithm_main_tab = "Дан взвешенный граф. Алгоритм Форда-Беллмана позволяет найти кратчайшие пути из\
 одной вершины графа до всех остальных, даже для графов, в которых веса ребер могут быть отрицательными."

Floyd_Warshall_algorithm_main_tab = "Дан взвешенный граф. Алгоритм позволяет найти кратчайшее расстояние между любыми\
 двумя вершинами в графе, при этом веса ребер могут быть как положительными, так и отрицательными."

Prim_algorithm_main_tab = "Дан взвешенный неориентированный граф G с n вершинами и m рёбрами.\
 Алгоритм заключается в нахождении минимального остовного дерева."

Kruskal_algorithm_main_tab = "Дан взвешенный неориентированный граф G с n вершинами и m рёбрами.\
 Алгоритм заключается в нахождении минимального остовного дерева."

Ford_Fulkerson_algorithm_main_tab = "Алгоритм решает задачу нахождения максимального потока в транспортной сети."


# ------------- Definition of algorithms in algorithms_tab -------------- #
# maximal
Ford_Bellman_algorithm_algorithms_tab = "\
    Алгоритм носит имя двух американских учёных: Ричарда Беллмана (Richard Bellman) и Лестера Форда (Lester Ford). \
Форд фактически изобрёл этот алгоритм в 1956 г. при изучении другой математической задачи, подзадача которой \
свелась к поиску кратчайшего пути в графе, и Форд дал набросок решающего эту задачу алгоритма. Беллман в 1958 г. \
опубликовал статью, посвящённую конкретно задаче нахождения кратчайшего пути, и в этой статье он чётко \
сформулировал алгоритм в том виде, в котором он известен нам сейчас.\n\n\
    Пусть дан ориентированный взвешенный граф G с n вершинами и m рёбрами, и указана некоторая вершина v. \
Требуется найти длины кратчайших путей от вершины v до всех остальных вершин. В отличие от алгоритма Дейкстры, \
этот алгоритм применим также и к графам, содержащим рёбра отрицательного веса. Впрочем, если граф содержит \
отрицательный цикл, то, понятно, кратчайшего пути до некоторых вершин может не существовать (по причине того, \
что вес кратчайшего пути должен быть равен минус бесконечности); впрочем, этот алгоритм можно модифицировать, \
чтобы он сигнализировал о наличии цикла отрицательного веса, или даже выводил сам этот цикл.\n\n \
    Мы считаем, что граф не содержит цикла отрицательного веса. Случай наличия отрицательного цикла будет \
рассмотрен ниже в отдельном разделе. Заведём массив расстояний d[0...n-1], который после отработки алгоритма \
будет содержать ответ на задачу.В начале работы мы заполняем его следующим образом: d[v] = 0, а все остальные \
элементы d[] равны бесконечности INF. Сам алгоритм Форда-Беллмана представляет из себя несколько фаз. На каждой фазе \
просматриваются все рёбра графа, и алгоритм пытается произвести релаксацию вдоль каждого ребра (a,b) стоимости c. \
Релаксация вдоль ребра — это попытка улучшить значение d[b] значением d[a] + c. Фактически это значит, что мы \
пытаемся улучшить ответ для вершины b, пользуясь ребром (a,b) и текущим ответом для вершины a. \
Утверждается, что достаточно n-1 фазы алгоритма, чтобы корректно посчитать длины всех кратчайших путей в графе. \
Для недостижимых вершин расстояние d[] останется равным бесконечности INF.\n\n\
    Для алгоритма Форда-Беллмана, в отличие от многих других графовых алгоритмов, более удобно представлять граф \
в виде одного списка всех рёбер (а не n списков рёбер — рёбер из каждой вершины). В приведённой реализации заводится \
структура данных edge для ребра. Входными данными для алгоритма являются числа n, m, список e рёбер, и номер \
стартовой вершины v. Все номера вершин нумеруются с 0 по n-1.\n\n\
    Пример реализации на C++:\n\n"

code_Ford_Bellman = ".\interface\pictures\Ford_Bellman.png"

# foxford
dfs_algorithms_tab = "\
    Алгоритм поиска (или обхода) в глубину (англ. depth-first search, DFS) позволяет построить обход ориентированного \
или неориентированного графа, при котором посещаются все вершины, доступные из начальной вершины.\n\n \
    Отличие поиска в глубину от поиска в ширину заключается в том, что (в случае неориентированного графа) результатом \
алгоритма поиска в глубину является некоторый маршрут, следуя которому можно обойти последовательно все вершины \
графа, доступные из начальной вершины. Этим он принципиально отличается от поиска в ширину, где одновременно \
обрабатывается множество вершин, в поиске в глубину в каждый момент исполнения алгоритма обрабатывается только \
одна вершина. С другой стороны, поиск в глубину не находит кратчайших путей, зато он применим в ситуациях, \
когда граф неизвестен целиком, а исследуется каким-то автоматизированным устройством.\n\n \
    Если же граф ориентированный, то поиск в глубину строит дерево путей из начальной вершины во все доступные из нее. \
Допустим, есть исследователь, который ходит по вершинам. Очевидная последовательность действий исследователя такая:\n\
        1) Пойти в какую-нибудь смежную вершину, не посещенную ранее.\n\
        2) Запустить из этой вершины алгоритм обхода в глубину\n\
        3) Вернуться в начальную вершину.\n\
        4) Повторить пункты 1-3 для всех не посещенных ранее смежных вершин.\n\n\
    Для реализации алгоритма понадобится отмечать, в каких вершинах был исследователь, а в каких — нет. Пометку будем \
делать в списке visited, где visited[i] == True для посещенных вершин, и visited[i] == false для непосещенных. \
Пометка «о посещении вершиных» ставится при заходе в эту вершину.\n\n\
    Поскольку целью обхода в глубину зачастую является построение дерева обхода в глубину, то сразу же будем \
хранить предшественника для каждой вершины.\n\n\
Алгоритм обхода в глубину оформим в виде рекурсивной функции dfs, где start — номер вершины,\
из которой запускается обход.\n\n\
    Пример реализации на C++:\n\n"

code_dfs = ""

#maximal
bfs_algorithms_tab = "\
    Поиск в ширину (обход в ширину, breadth-first search) — это один из основных алгоритмов на графах. \
В результате поиска в ширину находится путь кратчайшей длины в невзвешенном графе, т.е. путь, содержащий \
наименьшее число рёбер. Алгоритм работает за O (n+m), где n — число вершин, m — число рёбер.\n\n\
    На вход алгоритма подаётся заданный граф (невзвешенный), и номер стартовой вершины s. Граф может быть как \
ориентированным, так и неориентированным, для алгоритма это не важно.\n\n\
    Сам алгоритм можно понимать как процесс \"поджигания\" графа: на нулевом шаге поджигаем только вершину s. \
На каждом следующем шаге огонь с каждой уже горящей вершины перекидывается на всех её соседей; т.е. за одну итерацию \
алгоритма происходит расширение \"кольца огня\" в ширину на единицу (отсюда и название алгоритма).\n\n\
    Более строго это можно представить следующим образом. Создадим очередь q, в которую будут помещаться горящие \
вершины, а также заведём булевский массив  used[], в котором для каждой вершины будем отмечать, горит она уже \
или нет (или иными словами, была ли она посещена).\n\n\
    Изначально в очередь помещается только вершина s, и used[s] = true, а для всех остальных вершин  used[] = false. \
Затем алгоритм представляет собой цикл: пока очередь не пуста, достать из её головы одну вершину, просмотреть все \
рёбра, исходящие из этой вершины, и если какие-то из просмотренных вершин ещё не горят, то поджечь их и \
поместить в конец очереди.\n\n\
    В итоге, когда очередь опустеет, обход в ширину обойдёт все достижимые из s вершины, причём до каждой дойдёт \
кратчайшим путём. Также можно посчитать длины кратчайших путей (для чего просто надо завести массив длин путей d[]), \
и компактно сохранить информацию, достаточную для восстановления всех этих кратчайших путей (для этого надо завести \
массив \"предков\" p[], в котором для каждой вершины хранить номер вершины, по которой мы попали в эту вершину).\n\n\
    Пример реализации на C++:\n\n"

code_bfs = ""

# фоксфорд
Dijkstra_algorithm_algorithms_tab = "\
    Алгоритм Дейкстры назван в честь голландского ученого Эдсгера Дейкстры (Edsger Dijkstra). Алгоритм был предложен \
в 1959 году для нахождения кратчайших путей от одной вершины до всех остальных в ориентированном взвешенном графе, \
при условии, что все ребра в графе имеют неотрицательные веса.\n\n\
    Рассмотрим две модели хранения взвешенного графа в памяти. В первой модели (матрица весов, аналог матрицы \
смежности) будем считать, что вес ребра из вершины i в вершину j равен w[i][j], то есть в матрице w хранятся веса \
ребра для любых двух вершин. Если из вершины i в вершину j нет ребра, то w[i][j]==INF для некоторого специального \
значения константы INF.\n\n\
    Алгоритм Дейкстры относится к так называемым «жадным» алгоритмам. Пусть расстояние от начальной вершины start до \
вершины i хранится в массиве dist[i]. Начальные значения dist[start]=0, dist[i]=INF для всех остальных вершин i. \
То есть в самом начале алгоритму известен путь из вершины start до вершины start длины 0, а до остальных вершин \
кратчайшие пути неизвестны. Между тем алгоритм будет постепенно улучшать значения в массиве dist, в результате \
получит кратчайшие расстояния до всех вершин.\n\n\
    Основная идея для улучшения называется «релаксацией ребра». Пусть из вершины i в вершину j есть ребро веса w[i][j] \
,при этом выполнено неравенство dist[i] + w[i][j] < dist[j]. То есть можно построить маршрут из начальной вершины до \
вершины i и добавить к нему ребро из i в j, и суммарная стоимость такого маршрута будет меньше, чем известная ранее \
стоимость маршрута из начальной вершины в вершину j. Тогда можно улучшить значение dist[j], присвоив \
dist[j] = dist[i] + w[i][j].\n\n\
    В алгоритме Дейкстры вершины красятся в два цвета, будем говорить, что вершина «неокрашенная» или «окрашенная». \
Изначально все вершины неокрашенные. Если алгоритм Дейкстры покрасил вершину i, то это означает, что найденное \
значение dist[i] является наилучшим возможным и в последствии не будет улучшаться, то есть значение dist[i] является \
кратчайшим расстоянием от начальной вершины до вершины i. Если же вершина не покрашена, то величина dist[i] для такой \
вершины i равна кратчайшему пути из вершины start до вершины i, который проходит только по покрашенным \
вершинам (за исключением самой вершины i).\n\n\
    На каждом шаге алгоритма Дейкстры красится одна новая вершина. В качестве такой вершины выбирается неокрашенная \
вершина i с наименьшим значением D[i]. Затем рассматриваются все ребра, исходящие из вершины i, и производится \
релаксация этих ребер, то есть улучшаются расстояния до вершин, смежных с i.\n\n\
Алгоритм заканчивается, когда на очередном шаге не останется неокрашенных вершин или если расстояние до всех \
неокрашенных вершин будет равно INF (то есть эти вершины являются недостижимыми).\n\n\
    Пусть  — число вершин в графе, вершины пронумерованы от 0 до . Номер начальной вершины — start и \
веса ребер хранятся в матрице w.\n\n\
    Пример реализации на C++:\n\n"

code_Dijkstra = ""

#maximal
Floyd_Warshall_algorithm_algorithms_tab = "\
    Этот алгоритм был одновременно опубликован в статьях Роберта Флойда (Robert Floyd) и Стивена Уоршелла (Варшалла) \
(Stephen Warshall) в 1962 г., по имени которых этот алгоритм и называется в настоящее время. Впрочем, в 1959 г. \
Бернард Рой (Bernard Roy) опубликовал практически такой же алгоритм, но его публикация осталась незамеченной.\n\n\
    Дан ориентированный или неориентированный взвешенный граф G с n вершинами. Требуется найти значения всех величин \
d_{ij} — длины кратчайшего пути из вершины i в вершину j.\n\n\
    Предполагается, что граф не содержит циклов отрицательного веса (тогда ответа между некоторыми парами вершин может \
просто не существовать — он будет бесконечно маленьким).\n\n\
    Ключевая идея алгоритма — разбиение процесса поиска кратчайших путей на фазы.\n\n\
    Перед k-ой фазой (k = 1...n) считается, что в матрице расстояний d[][] сохранены длины таких кратчайших путей, \
которые содержат в качестве внутренних вершин только вершины из множества \{ 1, 2, \ldots, k-1 \} (вершины графа мы \
нумеруем, начиная с единицы).\n\n\
    Иными словами, перед k-ой фазой величина d[i][j] равна длине кратчайшего пути из вершины i в вершину j, если этому \
пути разрешается заходить только в вершины с номерами, меньшими k (начало и конец пути не считаются).\n\n\
    Легко убедиться, что чтобы это свойство выполнилось для первой фазы, достаточно в матрицу расстояний d[][] \
записать матрицу смежности графа: d[i][j] = g[i][j] — стоимости ребра из вершины i в вершину j. При этом, если между \
какими-то вершинами ребра нет, то записать следует величину \"бесконечность\" INF. Из вершины в саму себя всегда \
следует записывать величину 0, это критично для алгоритма.\n\n\
    Пусть теперь мы находимся на k-ой фазе, и хотим пересчитать матрицу d[][] таким образом, чтобы она соответствовала \
требованиям уже для k+1-ой фазы. Зафиксируем какие-то вершины i и j. У нас возникает два принципиально разных \
случая:\n\n\
        1) Кратчайший путь из вершины i в вершину j, которому разрешено дополнительно проходить через вершины \
{ 1, 2,..., k }, совпадает с кратчайшим путём, которому разрешено \
проходить через вершины множества { 1, 2,..., k-1 }.\n\
           В этом случае величина d[i][j] не изменится при переходе с k-ой на k+1-ую фазу.\n\n\
        2) \"Новый\" кратчайший путь стал лучше \"старого\" пути.\n\
            Это означает, что \"новый\" кратчайший путь проходит через вершину k. Сразу отметим, что мы не потеряем \
общности, рассматривая далее только простые пути (т.е. пути, не проходящие по какой-то вершине дважды).\n\
            Тогда заметим, что если мы разобьём этот \"новый\" путь вершиной k на две половинки (одна идущая i => k, \
а другая — k => j), то каждая из этих половинок уже не заходит в вершину k. Но тогда получается, что длина \
каждой из этих половинок была посчитана ещё на k-1-ой фазе или ещё раньше, и нам достаточно взять просто \
        сумму d[i][k] + d[k][j], она и даст длину \"нового\" кратчайшего пути.\n\n\
    Объединяя эти два случая, получаем, что на k-ой фазе требуется пересчитать длины кратчайших путей между \
всеми парами вершин i и j следующим образом:\n\
    new_d[i][j] = min (d[i][j], d[i][k] + d[k][j]);\n\n\
    Таким образом, вся работа, которую требуется произвести на k-ой фазе — это перебрать все пары вершин и пересчитать \
длину кратчайшего пути между ними. В результате после выполнения n-ой фазы в матрице расстояний d[i][j] будет записана \
длина кратчайшего пути между i и j, либо INF, если пути между этими вершинами не существует.\n\n\
    Последнее замечание, которое следует сделать, — то, что можно не создавать отдельную матрицу new_d[][] \
для временной матрицы кратчайших путей на k-ой фазе: все изменения можно делать сразу в матрице d[][]. В самом деле, \
если мы улучшили (уменьшили) какое-то значение в матрице расстояний, мы не могли ухудшить тем самым длину кратчайшего \
пути для каких-то других пар вершин, обработанных позднее.\n\n\
    Асимптотика алгоритма, очевидно, составляет O (n^3).\n\n\
    Пример реализации на C++:\n\n"

code_Floyd_Warshall = ""

Kruskal_algorithm_algorithms_tab = ""
code_Kruskal = ""

Prim_algorithm_algorithms_tab = ""
code_Prim = ""

Ford_Fulkerson_algorithm_algorithms_tab = ""
code_Ford_Fulkerson = ""