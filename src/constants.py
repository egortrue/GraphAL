# ---------------------------------------------------------------------- #
#                         Define constants                               #
# ---------------------------------------------------------------------- #


# ----------------------- Common constants ----------------------------- #
FONT_12 = 'Calibri 12'
FONT_14 = 'Calibri 14'
SIZE_BUTTON = (8, 1)


# ----------------------- Main tab constants --------------------------- #
SIZE_LABEL_MAIN_TAB = (11, 1)
SIZE_INPUT_MAIN_TAB = (14, 1)


# ----------------------- Preview tab constants ------------------------ #
COLOR_IN_PREVIEW = 'white'


# --------------- Definition of algorithms in main_tab ----------------- #

dfs_main_tab = "Дан произвольный граф. Алгоритм поиска в глубину позволяет построить обход графа,\
при котором посещаются все вершины, доступные из начальной вершины."

bfs_main_tab = "Дан невзвешенный (ориентированный или неориентированный) граф.\
 Алгоритм поиска в ширину позволяет найти кратчайшие пути из одной вершины до всех остальных вершин."

Dijkstra_algorithm_main_tab = "Дан взвешенный ориентированный граф. Алгоритм позволяет найти кратчайшие пути от\
одной вершины до всех остальных, при условии, что все ребра в графе имеют неотрицательные веса."

Ford_Bellman_algorithm_main_tab = "(BETA VERSION)\nДан взвешенный граф. Алгоритм Форда-Беллмана позволяет найти кратчайшие пути из\
 одной вершины графа до всех остальных, даже для графов, в которых веса ребер могут быть отрицательными."

Floyd_Warshall_algorithm_main_tab = "Дан взвешенный граф. Алгоритм позволяет найти кратчайшее расстояние между любыми\
 двумя вершинами в графе, при этом веса ребер могут быть как положительными, так и отрицательными."

Prim_algorithm_main_tab = "Дан взвешенный неориентированный граф G с n вершинами и m рёбрами.\
 Алгоритм заключается в нахождении минимального остовного дерева."

Kruskal_algorithm_main_tab = "Дан взвешенный неориентированный граф G с n вершинами и m рёбрами.\
 Алгоритм заключается в нахождении минимального остовного дерева."

Ford_Fulkerson_algorithm_main_tab = "(BETA VERSION)\nАлгоритм решает задачу нахождения максимального потока в транспортной сети."


# ------------- Definition of algorithms in algorithms_tab -------------- #
# maximal
Ford_Bellman_algorithm_algorithms_tab = "\
    Алгоритм носит имя двух американских учёных: Ричарда Беллмана (Richard Bellman) и Лестера Форда (Lester Ford). \
Форд фактически изобрёл этот алгоритм в 1956 г. при изучении другой математической задачи, подзадача которой \
свелась к поиску кратчайшего пути в графе, и Форд дал набросок решающего эту задачу алгоритма. Беллман в 1958 г. \
опубликовал статью, посвящённую конкретно задаче нахождения кратчайшего пути, и в этой статье он чётко \
сформулировал алгоритм в том виде, в котором он известен нам сейчас.\n\n\
    Пусть дан ориентированный взвешенный граф G с n вершинами и m рёбрами, и указана некоторая вершина v. \
Требуется найти длины кратчайших путей от вершины v до всех остальных вершин. В отличие от алгоритма Дейкстры, \
этот алгоритм применим также и к графам, содержащим рёбра отрицательного веса. Впрочем, если граф содержит \
отрицательный цикл, то, понятно, кратчайшего пути до некоторых вершин может не существовать (по причине того, \
что вес кратчайшего пути должен быть равен минус бесконечности); впрочем, этот алгоритм можно модифицировать, \
чтобы он сигнализировал о наличии цикла отрицательного веса, или даже выводил сам этот цикл.\n\n \
    Мы считаем, что граф не содержит цикла отрицательного веса. Случай наличия отрицательного цикла будет \
рассмотрен ниже в отдельном разделе. Заведём массив расстояний d[0...n-1], который после отработки алгоритма \
будет содержать ответ на задачу.В начале работы мы заполняем его следующим образом: d[v] = 0, а все остальные \
элементы d[] равны бесконечности INF. Сам алгоритм Форда-Беллмана представляет из себя несколько фаз. На каждой фазе \
просматриваются все рёбра графа, и алгоритм пытается произвести релаксацию вдоль каждого ребра (a,b) стоимости c. \
Релаксация вдоль ребра — это попытка улучшить значение d[b] значением d[a] + c. Фактически это значит, что мы \
пытаемся улучшить ответ для вершины b, пользуясь ребром (a,b) и текущим ответом для вершины a. \
Утверждается, что достаточно n-1 фазы алгоритма, чтобы корректно посчитать длины всех кратчайших путей в графе. \
Для недостижимых вершин расстояние d[] останется равным бесконечности INF.\n\n\
    Для алгоритма Форда-Беллмана, в отличие от многих других графовых алгоритмов, более удобно представлять граф \
в виде одного списка всех рёбер (а не n списков рёбер — рёбер из каждой вершины). В приведённой реализации заводится \
структура данных edge для ребра. Входными данными для алгоритма являются числа n, m, список e рёбер, и номер \
стартовой вершины v. Все номера вершин нумеруются с 0 по n-1.\n\n\
    Источник: https://e-maxx.ru/algo/ford_bellman\n\n"

code_Ford_Bellman = ".\interface\pictures\Ford_Bellman.png"

# foxford
dfs_algorithms_tab = "\
    Алгоритм поиска (или обхода) в глубину (англ. depth-first search, DFS) позволяет построить обход ориентированного \
или неориентированного графа, при котором посещаются все вершины, доступные из начальной вершины.\n\n \
    Отличие поиска в глубину от поиска в ширину заключается в том, что (в случае неориентированного графа) результатом \
алгоритма поиска в глубину является некоторый маршрут, следуя которому можно обойти последовательно все вершины \
графа, доступные из начальной вершины. Этим он принципиально отличается от поиска в ширину, где одновременно \
обрабатывается множество вершин, в поиске в глубину в каждый момент исполнения алгоритма обрабатывается только \
одна вершина. С другой стороны, поиск в глубину не находит кратчайших путей, зато он применим в ситуациях, \
когда граф неизвестен целиком, а исследуется каким-то автоматизированным устройством.\n\n \
    Если же граф ориентированный, то поиск в глубину строит дерево путей из начальной вершины во все доступные из нее. \
Допустим, есть исследователь, который ходит по вершинам. Очевидная последовательность действий исследователя такая:\n\
        1) Пойти в какую-нибудь смежную вершину, не посещенную ранее.\n\
        2) Запустить из этой вершины алгоритм обхода в глубину\n\
        3) Вернуться в начальную вершину.\n\
        4) Повторить пункты 1-3 для всех не посещенных ранее смежных вершин.\n\n\
    Для реализации алгоритма понадобится отмечать, в каких вершинах был исследователь, а в каких — нет. Пометку будем \
делать в списке visited, где visited[i] == True для посещенных вершин, и visited[i] == false для непосещенных. \
Пометка «о посещении вершиных» ставится при заходе в эту вершину.\n\n\
    Поскольку целью обхода в глубину зачастую является построение дерева обхода в глубину, то сразу же будем \
хранить предшественника для каждой вершины.\n\n\
Алгоритм обхода в глубину оформим в виде рекурсивной функции dfs, где start — номер вершины,\
из которой запускается обход.\n\n\
    Источник: https://foxford.ru/wiki/informatika/algoritm-poiska-v-glubinu\n\n"

code_dfs = ".\interface\pictures\DFS.png"

#maximal
bfs_algorithms_tab = "\
    Поиск в ширину (обход в ширину, breadth-first search) — это один из основных алгоритмов на графах. \
В результате поиска в ширину находится путь кратчайшей длины в невзвешенном графе, т.е. путь, содержащий \
наименьшее число рёбер. Алгоритм работает за O (n+m), где n — число вершин, m — число рёбер.\n\n\
    На вход алгоритма подаётся заданный граф (невзвешенный), и номер стартовой вершины s. Граф может быть как \
ориентированным, так и неориентированным, для алгоритма это не важно.\n\n\
    Сам алгоритм можно понимать как процесс \"поджигания\" графа: на нулевом шаге поджигаем только вершину s. \
На каждом следующем шаге огонь с каждой уже горящей вершины перекидывается на всех её соседей; т.е. за одну итерацию \
алгоритма происходит расширение \"кольца огня\" в ширину на единицу (отсюда и название алгоритма).\n\n\
    Более строго это можно представить следующим образом. Создадим очередь q, в которую будут помещаться горящие \
вершины, а также заведём булевский массив  used[], в котором для каждой вершины будем отмечать, горит она уже \
или нет (или иными словами, была ли она посещена).\n\n\
    Изначально в очередь помещается только вершина s, и used[s] = true, а для всех остальных вершин  used[] = false. \
Затем алгоритм представляет собой цикл: пока очередь не пуста, достать из её головы одну вершину, просмотреть все \
рёбра, исходящие из этой вершины, и если какие-то из просмотренных вершин ещё не горят, то поджечь их и \
поместить в конец очереди.\n\n\
    В итоге, когда очередь опустеет, обход в ширину обойдёт все достижимые из s вершины, причём до каждой дойдёт \
кратчайшим путём. Также можно посчитать длины кратчайших путей (для чего просто надо завести массив длин путей d[]), \
и компактно сохранить информацию, достаточную для восстановления всех этих кратчайших путей (для этого надо завести \
массив \"предков\" p[], в котором для каждой вершины хранить номер вершины, по которой мы попали в эту вершину).\n\n\
    Источник: https://e-maxx.ru/algo/bfs\n\n"

code_bfs = ".\interface\pictures\BFS.png"

# фоксфорд
Dijkstra_algorithm_algorithms_tab = "\
    Алгоритм Дейкстры назван в честь голландского ученого Эдсгера Дейкстры (Edsger Dijkstra). Алгоритм был предложен \
в 1959 году для нахождения кратчайших путей от одной вершины до всех остальных в ориентированном взвешенном графе, \
при условии, что все ребра в графе имеют неотрицательные веса.\n\n\
    Рассмотрим две модели хранения взвешенного графа в памяти. В первой модели (матрица весов, аналог матрицы \
смежности) будем считать, что вес ребра из вершины i в вершину j равен w[i][j], то есть в матрице w хранятся веса \
ребра для любых двух вершин. Если из вершины i в вершину j нет ребра, то w[i][j]==INF для некоторого специального \
значения константы INF.\n\n\
    Алгоритм Дейкстры относится к так называемым «жадным» алгоритмам. Пусть расстояние от начальной вершины start до \
вершины i хранится в массиве dist[i]. Начальные значения dist[start]=0, dist[i]=INF для всех остальных вершин i. \
То есть в самом начале алгоритму известен путь из вершины start до вершины start длины 0, а до остальных вершин \
кратчайшие пути неизвестны. Между тем алгоритм будет постепенно улучшать значения в массиве dist, в результате \
получит кратчайшие расстояния до всех вершин.\n\n\
    Основная идея для улучшения называется «релаксацией ребра». Пусть из вершины i в вершину j есть ребро веса w[i][j] \
,при этом выполнено неравенство dist[i] + w[i][j] < dist[j]. То есть можно построить маршрут из начальной вершины до \
вершины i и добавить к нему ребро из i в j, и суммарная стоимость такого маршрута будет меньше, чем известная ранее \
стоимость маршрута из начальной вершины в вершину j. Тогда можно улучшить значение dist[j], присвоив \
dist[j] = dist[i] + w[i][j].\n\n\
    В алгоритме Дейкстры вершины красятся в два цвета, будем говорить, что вершина «неокрашенная» или «окрашенная». \
Изначально все вершины неокрашенные. Если алгоритм Дейкстры покрасил вершину i, то это означает, что найденное \
значение dist[i] является наилучшим возможным и в последствии не будет улучшаться, то есть значение dist[i] является \
кратчайшим расстоянием от начальной вершины до вершины i. Если же вершина не покрашена, то величина dist[i] для такой \
вершины i равна кратчайшему пути из вершины start до вершины i, который проходит только по покрашенным \
вершинам (за исключением самой вершины i).\n\n\
    На каждом шаге алгоритма Дейкстры красится одна новая вершина. В качестве такой вершины выбирается неокрашенная \
вершина i с наименьшим значением D[i]. Затем рассматриваются все ребра, исходящие из вершины i, и производится \
релаксация этих ребер, то есть улучшаются расстояния до вершин, смежных с i.\n\n\
Алгоритм заканчивается, когда на очередном шаге не останется неокрашенных вершин или если расстояние до всех \
неокрашенных вершин будет равно INF (то есть эти вершины являются недостижимыми).\n\n\
    Пусть  — число вершин в графе, вершины пронумерованы от 0 до . Номер начальной вершины — start и \
веса ребер хранятся в матрице w.\n\n\
    Источник: https://foxford.ru/wiki/informatika/algoritm-deykstry\n\n"

code_Dijkstra = ".\interface\pictures\Dijkstra.png"

#maximal
Floyd_Warshall_algorithm_algorithms_tab = "\
    Этот алгоритм был одновременно опубликован в статьях Роберта Флойда (Robert Floyd) и Стивена Уоршелла (Варшалла) \
(Stephen Warshall) в 1962 г., по имени которых этот алгоритм и называется в настоящее время. Впрочем, в 1959 г. \
Бернард Рой (Bernard Roy) опубликовал практически такой же алгоритм, но его публикация осталась незамеченной.\n\n\
    Дан ориентированный или неориентированный взвешенный граф G с n вершинами. Требуется найти значения всех величин \
d_{ij} — длины кратчайшего пути из вершины i в вершину j.\n\n\
    Предполагается, что граф не содержит циклов отрицательного веса (тогда ответа между некоторыми парами вершин может \
просто не существовать — он будет бесконечно маленьким).\n\n\
    Ключевая идея алгоритма — разбиение процесса поиска кратчайших путей на фазы.\n\n\
    Перед k-ой фазой (k = 1...n) считается, что в матрице расстояний d[][] сохранены длины таких кратчайших путей, \
которые содержат в качестве внутренних вершин только вершины из множества \{ 1, 2, \ldots, k-1 \} (вершины графа мы \
нумеруем, начиная с единицы).\n\n\
    Иными словами, перед k-ой фазой величина d[i][j] равна длине кратчайшего пути из вершины i в вершину j, если этому \
пути разрешается заходить только в вершины с номерами, меньшими k (начало и конец пути не считаются).\n\n\
    Легко убедиться, что чтобы это свойство выполнилось для первой фазы, достаточно в матрицу расстояний d[][] \
записать матрицу смежности графа: d[i][j] = g[i][j] — стоимости ребра из вершины i в вершину j. При этом, если между \
какими-то вершинами ребра нет, то записать следует величину \"бесконечность\" INF. Из вершины в саму себя всегда \
следует записывать величину 0, это критично для алгоритма.\n\n\
    Пусть теперь мы находимся на k-ой фазе, и хотим пересчитать матрицу d[][] таким образом, чтобы она соответствовала \
требованиям уже для k+1-ой фазы. Зафиксируем какие-то вершины i и j. У нас возникает два принципиально разных \
случая:\n\n\
        1) Кратчайший путь из вершины i в вершину j, которому разрешено дополнительно проходить через вершины \
{ 1, 2,..., k }, совпадает с кратчайшим путём, которому разрешено \
проходить через вершины множества { 1, 2,..., k-1 }.\n\
           В этом случае величина d[i][j] не изменится при переходе с k-ой на k+1-ую фазу.\n\n\
        2) \"Новый\" кратчайший путь стал лучше \"старого\" пути.\n\
            Это означает, что \"новый\" кратчайший путь проходит через вершину k. Сразу отметим, что мы не потеряем \
общности, рассматривая далее только простые пути (т.е. пути, не проходящие по какой-то вершине дважды).\n\
            Тогда заметим, что если мы разобьём этот \"новый\" путь вершиной k на две половинки (одна идущая i => k, \
а другая — k => j), то каждая из этих половинок уже не заходит в вершину k. Но тогда получается, что длина \
каждой из этих половинок была посчитана ещё на k-1-ой фазе или ещё раньше, и нам достаточно взять просто \
        сумму d[i][k] + d[k][j], она и даст длину \"нового\" кратчайшего пути.\n\n\
    Объединяя эти два случая, получаем, что на k-ой фазе требуется пересчитать длины кратчайших путей между \
всеми парами вершин i и j следующим образом:\n\
    new_d[i][j] = min (d[i][j], d[i][k] + d[k][j]);\n\n\
    Таким образом, вся работа, которую требуется произвести на k-ой фазе — это перебрать все пары вершин и пересчитать \
длину кратчайшего пути между ними. В результате после выполнения n-ой фазы в матрице расстояний d[i][j] будет записана \
длина кратчайшего пути между i и j, либо INF, если пути между этими вершинами не существует.\n\n\
    Последнее замечание, которое следует сделать, — то, что можно не создавать отдельную матрицу new_d[][] \
для временной матрицы кратчайших путей на k-ой фазе: все изменения можно делать сразу в матрице d[][]. В самом деле, \
если мы улучшили (уменьшили) какое-то значение в матрице расстояний, мы не могли ухудшить тем самым длину кратчайшего \
пути для каких-то других пар вершин, обработанных позднее.\n\n\
    Асимптотика алгоритма, очевидно, составляет O (n^3).\n\n\
    Источник: https://e-maxx.ru/algo/floyd_warshall_algorithm\n\n"

code_Floyd_Warshall = ".\interface\pictures\Floyd_Warshall.png"

Kruskal_algorithm_algorithms_tab = "\
    В алгоритме Краскала весь единый список ребер упорядочивается по неубыванию весов ребра. Далее ребра перебираются \
от ребер с меньшим весом к большему, и очередное ребро добавляется к каркасу, если оно не образовывает цикла с ранее \
выбранными ребрами. В частности, первым всегда выбирается одно из ребер минимального веса в графе.\n\n\
    Для проверки того, что выбранные ребра не образовывает цикл, будем представлять граф, как объединение нескольких \
компонент связности. В самом начале, когда ни одно ребро графа не  выбрано, каждая вершина является отдельной \
компонентой связности. По мере добавления новых ребер компоненты связности будут объединяться, пока не получится одна \
общая компонента связности. Пронумеруем все компонтенты связности и для каждой вершины будем хранить номер ее \
компоненты связности, таким образом, в самом начале для каждой вершины номер ее компоненты связности будет равен \
номеру самой вершины,а в конце у всех вершин будут одинаковые номера компоненты связности, которой они принадлежал.\n\n\
    При рассмотрении очередного ребра посмотрим номера компонент связности, соответствующих концам этого ребра. \
Если эти номера совпадают, то ребро соединяет две вершины, уже лежащие в одной компоненте связности, поэтому \
добавление этого ребра образовывает цикл. Если же ребро соединяет две разные компоненты связности, например, с \
номерами a и b, то ребро добавляется к части основного дерева, а эти две компоненты связности объединяются вместе. \
Для этого можно, например, всем вершинам, которые раньше находились в компоненте b изменить номер компоненты на a.\n\n\
    В этом примере граф задается списком ребер, ребро задается тремя числами (начало, конец, вес), ребра хранятся в \
виде кортежей в списке Edges, причем первым элементом кортежа является вес ребра, чтобы сортировка осуществлялась \
по весу ребер. Вершины нумеруются начиная с нуля, в списке Comp хранится номер компоненты связсности, к которой \
отнесена данная вершина, в переменной Ans хранится вес минимального остовного дерева, который увеличивается на вес \
выбираемого ребра.\n\n\
    Сложность такого алгоритма O(M*logM + N^2), так как алгоритм сначала сортирует все ребра, затем просматривает \
ребра по одному, и при этом N - 1 раз производится объединение двух компонент связности, что требует просмотра \
всего списка вершин.\n\n\
    Источник: https://foxford.ru/wiki/informatika/postroenie-minimalnogo-ostovnogo-dereva\n\n"
code_Kruskal = ".\interface\pictures\Kruskal.png"

Prim_algorithm_algorithms_tab = "\
    Алгоритм Прима во многом похож на алгоритм Дейкстры. В этом алгоритме также есть множество уже покрашенных вершин, \
в алгоритме Прима это множество есть множество уже присоединенных к остовному дереву вершин. Начинается с одной \
произвольной вершины, затем новые вершины добавляются к остовному дереву по одному. На каждом шаге к уже построенному \
фрагменту дереву добавляется одна новая вершина, соединенная ребром с какой-то вершиной, уже включенной в дерево. \
При этом выбирается ребро с минимально возможным весом из всех таких подходящих ребер. Для этого (как и в алгоритме \
Дейкстры) для каждой вершины в массиве dist хранится минимальный вес ребра, при помощи которого эту вершину можно \
присоединить к уже построенному фрагменту дерева и на каждом шаге выбирается вершина из числа еще непокрашенных, \
для которой это значение минимально.\n\n\
    После нахождения такой вершины и присоединения ее к остовному дереву, рассматриваются все ребра, исходящие из этой \
вершины, и значения dist уменьшаются для других вершин, соединенных с присоединенной ребром, если вес этого ребра \
меньше, чем ранее известный вес «присоединения» данной вершины к дереву.\n\n\
    Приведем алгоритм Прима, записанный на графе, хранимом в виде матрицы смежности.\n\n\
    Инициализация алгоритма начинается с того, что значение dist устанавливается раным 0 для одной вершины \
(например, номер 0) и бесконечности для всех остальных вершин. Тем самым эта вершина будет добавлена первой к пустому \
множеству вершин остовного дерева, а всего цикл добавления вершин нужно будет выполнить N раз. Сложность такого \
алгоритма, как и алгоритма Дейкстры, составляет O(N^2).\n\n\
    Источник: https://foxford.ru/wiki/informatika/postroenie-minimalnogo-ostovnogo-dereva\n\n"
code_Prim = ".\interface\pictures\Prims.png"

Ford_Fulkerson_algorithm_algorithms_tab = "\
    Алгоритм Форда-Фалкерсона — решает задачу нахождения максимального потока в транспортной сети.\n\n\
    Задача о максимальном потоке для данной сети состоит в следующем: найти максимально возможную скорость \
производства (и потребления) вещества, при которой его еще можно доставить от истока к стоку при данных \
пропускных способностях труб.\n\n\
    Ключевую роль в методе Форда-Фалкерсона играют два понятия: остаточные сети и дополняющие пути. Пусть дана \
сеть и поток в ней. Тогда остаточная сеть состоит из тех ребер (называемых также остаточными), поток по которым \
можно увеличить. Заметим, что остаточное ребро не обязано быть ребром исходной сети. Такие \"странные\" ребра \
появляются когда имеется поток вещества в обратном направлении — ведь этот поток можно уменьшить. Назовем дополняющим \
путем простой путь из истока в сток в остаточной сети. Из определения остаточной сети вытекает, что по всем ребрам \
дополняющего пути можно переслать ещё сколько-то вещества, не превысив их пропускную способность. \
Величину наибольшего потока, который можно переслать по дополняющему пути назовем остаточной пропускной способностью \
пути. Очевидно, она равна значению минимального остаточного ребра, входящего в данный путь.\n\n\
    При выполнении каждой итерации метода Форда-Фалкерсона мы находим некоторый увеличивающий путь р, и поток f \
вдоль каждого ребра данного пути увеличивается на величину остаточной пропускной способности сf (р). \
Реализация данного метода вычисляет максимальный поток в графе G = (V, Е) путем обновления потока f[u,v] между каждой \
парой вершин и и v, соединенных ребром. Если вершины u и v не связаны ребром ни в одном направлении, неявно \
предполагается, что f[u, v] = 0. Предполагается, что значения пропускных способностей задаются вместе с \
графом и с (u, v) = 0, если (u, v) є Е.\n\n\
    Остаточная пропускная способность сf (u, v) вычисляется по формуле cf (u, v) = с (u, v) - f (u, v).\n\n\
    Некоторые дополнительные переменные для реализации:\n\n\
MAX_VERTICES - максимальное количество вершин\n\
NUM_VERTICES - число вершин в графе\n\
INFINITY = 10000 - условное число, обозначающее бесконечность\n\
f[MAX_VERTICES][MAX_VERTICES] - f[i][j] - поток, текущий от вершины i к j\n\
c[MAX_VERTICES][MAX_VERTICES] - c[i][j] - максимальная величина потока, способная течь по ребру (i,j)\n\n\
Набор вспомогательных переменных, используемых функцией FindPath - обхода в ширину\n\
Flow[MAX_VERTICES] - значение потока через данную вершину на данном шаге поиска\n\
Link[MAX_VERTICES] - Link[i] хранит номер предыдущей вешины на пути i -> исток\n\
Queue[MAX_VERTICES]; - очередь\n\
QP, QC - указатель начала очереди и число эл-тов в очереди, соответственно.\n\n\
    Источники: http://urban-sanjoo.narod.ru/ford-fulkerson.html\n\
https://informatics.mccme.ru/mod/book/view.php?id=448&chapterid=150\n\n"

code_Ford_Fulkerson = ".\interface\pictures\Ford_Fulkerson.png"